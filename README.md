# Minesweeper_game
Minesweeper game done in Visual Studio (Oct.2018)

For this game project I made a 10x10-square board of the Minesweeper game using C in Visual Studio.
 
The code starts from the main and calls the function start which randomizes the bombs and calculates the value for each square (by utilizing another function called countMines). In addition to the initializations the main uses a bool play which is true when a person is playing and wants to continue playing. While this is true it calls the functions printField and playerInput, which print the game board and asks for user input respectively. The next actions are based on the players input from options of opening a square, setting a flag and starting a new game.

Opening a square will call the function uncover which requests a user input for the column and row of the square that the player wants to open, which utilizes a function open which sees that if the value is zero it opens each square around it until there is an area with a border of numbers. The second option that the player can do is setting a flag which calls a function setFlag, which asks for user input of the placement and displays a question mark at the spot. Lastly there is the choice of starting a new game, which takes the program back to the start function.

After the choice has been made and the appropriate functions are used, the program goes back to the main and since the bool play is still true it loops back and prints the field again and asks for user input. When the printField function is used it also checks if the player has won or lost. If either is true it calls a bool newGame which asks whether the player wishes to continue, and the program proceeds accordingly either by closing it or returning true.

Many of these functions have calculations which won’t be seen by the player.

Throughout the project I learnt a lot about not only the code words and functionalities themselves, but also about trying to keep it structurally make sense and flow appropriately between all the various functions. A big part of succeeding in the organization of the code was writing things down and drawing graphs of how it should go. Also, a big lesson learned was to write the code so that you can do efficient debugging.

As foreshadowed in the previous statements, a problem I encountered was with the order of the functions and the statements inside of it, since most functions do a certain job and then go back to the previous one, which sometimes resulted in the code going through multiple functions to get back to where it would show something. Another complication I encountered multiple times was problems less with the code and more with Visual Studio like obscure quirks which were only resolved by shutting and starting Visual Studio again. Amongst those there were issues and bugs including multiple entries and exits from loops and certain condition placements inside functions. Some smaller problems also included argument conversions, trying to minimize the possibility of the user crashing the game, aesthetics and eventually the excessive testing and playing of the game.

Currently the code still has things that could be improved. For example, the code could still be structurally simplified and probably shortened, there is a certain point in the function uncover where the program could potentially crash if a user inputs something that they shouldn’t, and after a loss to start a new game the player must loop back to the selection options from which they can type the letter s for starting a new game. Nonetheless there are many parts of the code that I am proud of, including the usability, logic behind the calculations and the looping between the functions. Overall the fact that the game is usable is already an achievement and something I am pleased about.
